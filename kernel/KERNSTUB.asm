

;
; +-------------------------------------------------------------------------+
; |   This file has been generated by The Interactive Disassembler (IDA)    |
; |           Copyright (c) 2017 Hex-Rays, <support@hex-rays.com>           |
; |                      License info: 48-3FBD-7F04-2C                      |
; |                      Jiang Ying, Personal license                       |
; +-------------------------------------------------------------------------+
;
; Input SHA256 : CBD7A4013DCD287E15885AC27285E5CB4500C8ABA0F89A4BA759AFCC6BA32547
; Input MD5    : DFB075EE038AE8DA270F6EB093F5E5CB
; Input CRC32  : E750A45D

; File Name   : D:\research\win1.03\image\KERNEL\DEBUG\KERNEL.EXE
; Format      : MS-DOS executable (EXE)
; Base Address: 1000h Range: 10000h-1A200h Loaded length: A200h
; Entry Point : 1000:0

        TITLE   KERNSTUB - Assembly stub program for KERNEL.EXE
		
; This is the Windows entry point.
; It's the MZ component of the multi-mode executable.
; The sole purpose is to validate and load KERNEL. 
; Specifically, it validates the NE header, does paragraph alignment 
; and then loads the first code segment (which in KERNEL is the entry point) and jumps to it.

.686p
.mmx
.model large

include newexe.inc ; /libw/inc

; Segment type: Pure code
seg000 segment byte public 'CODE' use16
assume cs:seg000
assume es:nothing, ss:seg001, ds:nothing, fs:nothing, gs:nothing

public start
start proc far
	push    cs
	pop     ds
	assume ds:seg000
	mov     si, 130h
	add     si, 1FFh
	and     si, 0FE00h ; 0x200 - location of NE header in binary
	cmp     word ptr [si], 454Eh ; check for NE header magic
	jnz     short call_boot_failure ; jump to fail code if it is not 0x4E45 ("NE")
	mov     ax, ds
	cli		; Disable interrupts
	mov     ss, ax
	assume ss:seg000 ; si -> pointer to NE header
	mov     sp, si
	sti		; Enable interrupts
	mov     bx, [si].ne_autodata ; segment # of automatic data segment
	dec     bx
	jl      short load_segment
	shl     bx, 1
	shl     bx, 1
	shl     bx, 1
	add     bx, [si].ne_segtab ;  NE relative offset to segment table
	mov     ax, [bx+si]
	cmp     word ptr [si].ne_align, 0
	jnz     short shift_alignment
	mov     word ptr [si].ne_align, NSALIGN ; see newexe.inc, this is the default alignment shifting - 0x09

; shifts the segments to be on x86 paragraph boundaries
; this is only called if the executable header specifically specifies extra alignment count is requried
shift_alignment: 
	mov     cx, [si].ne_align
	sub     cx, 4 ; convert to paragraph boundaries (instead of 64-byte "sectors")
	shl     ax, cl
	mov     di, cs
	sub     di, 20h 
	add     di, ax

load_segment:
	mov     bx, [si].ne_csip + 2 ; number of code segments 
	dec     bx ; decrement bx 
	jl      short call_boot_failure ; fail to boot if there are no code segments
	; we are now booting
	; load the initial code segment, perform default alignment from the segment table so we can far return to the kernel entrypoint
	shl     bx, 1
	shl     bx, 1
	shl     bx, 1
	add     bx, [si].ne_segtab ; get the address of the NE segment table (get the first code segment)
	mov     ax, [bx+si] ; find the segment table
	mov     cx, [si].ne_align ; alignment shift count (so that segments can be aligned on a paragraph boundary)
	sub     cx, 4 ; segment table address is in paragraphs (16-bytes)
	shl     ax, cl
		mov     dx, cs
sub     dx, 20h 
add     dx, ax
push    dx
push    word ptr [si].ne_csip ; initial CSIP value from our first code segment
mov     ds, di
assume ds:nothing
mov     cx, si
add     cx, 200h, ; NE header location added to initial CS value (so that we don't execute the header)
jmp     short boot
align 10h

boot:
retf ; return to the code segment we just set up, which is the kernel entry point we determined from the NE header. Therefore we will now boot windows.

call_boot_failure:
call	boot_failure
start endp ; sp-analysis failed
; Attributes: noreturn

; Run on invalid NE header present during boot (no code segments or no NE magic). 
Prints message using DOS API and exits.
boot_failure proc near
; error message
db 'KERNSTUB: Error during boot',13,10,'$' ; terminated
pop     dx
push    cs
pop     ds
assume ds:seg000
mov     ah, 9
int     21h             ; DOS - PRINT STRING
                        ; DS:DX -> string terminated by "$"
mov     ax, 4C01h		; exit code is 1
int     21h             ; DOS - 2+ - QUIT WITH EXIT CODE (EXIT)
boot_failure endp ; sp-analysis failed ; AL = exit code

db 4Ch, 0
seg000 ends

end start